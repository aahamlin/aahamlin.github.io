---
layout: post
title: Create an AWS Amplify Elm Project
excerpt: My goal is to setup an Elm Progressive Web App on AWS Amplify Console. The backend will include GraphQL and DynamoDB. And include a build pipeline using AWS Amplify.
---

_Note: This is an unfinished and half-forgotten post._{:class="info"}

My goal is to setup an Elm Progressive Web App on AWS Amplify Console. The backend will include GraphQL and DynamoDB. And include a build pipeline using AWS Amplify.

I will create the progressive web app following this article [https://codeburst.io/how-to-make-an-elm-app-progressive-d2e17d2f6fea](https://codeburst.io/how-to-make-an-elm-app-progressive-d2e17d2f6fea).

I chose not to go the `create-elm-app` approach for the following reasons:
- its not upgraded to elm 0.19.1
- the npm install failed with fatal erros after given me a zillion deprecration warnings
- in general, I avoid these boilerplate setup programs due to bias

The steps I run through are:
1. Initialize a new elm 0.19.1 project
1. Initialize a node project
1. Install webpack-cli as a dev dependency

```
$ elm init
$ npm init
$ npm i --save-dev webpack-cli
```

Hmm, there are a number of updated steps not mentioned in the article because my local environment is missing some dependencies \(maybe the author installed them globally?\) and/or because the newer versions of elm and other modules.

```
$ npm i -D webpack@4
$ npm i -D file-loader
$ npm i -D elm-webpack-loader
$ npm i -D webpack-dev-server
```

After all this my package.json has been updated as follows.

> Note the project referenced by the article installs all of the above packages as "dependencies" rather than "devDependencies" but as the build output we are creating is all generated by webpack build steps, I think that that is incorrectly. *I may be wrong*. In which case, I'll come back and update this statement.

package.json:
```
{
    "main": "webpack.config.js",
    "dependencies": {},
    "devDependencies": {
        "elm-webpack-loader": "^6.0.1",
        "file-loader": "^6.0.0",
        "webpack": "^4.42.1",
        "webpack-cli": "^3.3.11",
        "webpack-dev-server": "^3.10.3",
    },
    "scripts": {
        "build": "webpack --mode=production",
        "start": "webpack-dev-server --port=3000 --mode=development",
        "test": "echo \"Error: no test specified\" && exit 1"
    },
}
```

When I run `npm run build` the errors about webpack, file-loader, and elm-webpack-loader have been resolved. But, there is a new error related to the updated version of Elm.

```
ERROR in ./src/Main.elm
Module build failed (from ./node_modules/elm-webpack-loader/index.js):
Error: Compiler process exited with error "node-elm-compiler received the `warn` option, but that was removed in Elm 0.19. Try re-running without passing the `warn` option."
    at /home/andrew/src/rezumei/node_modules/elm-webpack-loader/index.js:192:28
 @ ./src/index.js 6:10-31
 @ multi ./src/index.js
```

Easy enough, go to `webpack.config.js` and edit the elm-webpack-loader to remove the warn option.

Yay! The first build error goes away... but, another Elm 0.19.1 requirement pops up.

```
Compiling ...-- MODULE NAME MISSING -------------------------------------------- src/Main.elm

I need the module name to be declared at the top of this file, like this:

    module Main exposing (..)

Try adding that as the first line of your file!
```

After doing exactly what the Elm compiler told me to do. Success!

```
$ npm run build

> rezumei@1.0.0 build /home/andrew/src/rezumei
> npx webpack --mode=production

Running elm make /home/andrew/src/rezumei/src/Main.elm --output /tmp/2020318-14775-vm9mqh.xuc6h.js
Success! Compiled 1 module.

    Main ───> /tmp/2020318-14775-vm9mqh.xuc6h.js


Hash: d1ce025d10e2024ca6f3
Version: webpack 4.42.1
Time: 1488ms
Built at: 04/18/2020 3:19:52 PM
     Asset       Size  Chunks             Chunk Names
    app.js   23.9 KiB       0  [emitted]  app
index.html  266 bytes          [emitted]
Entrypoint app = app.js
[0] multi ./src/index.js 28 bytes {0} [built]
[1] ./src/index.js 236 bytes {0} [built]
[2] ./src/index.html 54 bytes {0} [built]
[3] ./src/Main.elm 88.1 KiB {0} [built]
```

So far so good. Our Elm app compiles successfully. However, when I run it `npm run start` the web output is a blank page. Looking at the webpack-dev-server output, the file being served is what will become the `app.js` file during the build step, in our case `src/index.js`.

```
$ npm run start

> rezumei@1.0.0 start /home/andrew/src/rezumei
> webpack-dev-server --port=3000 --mode=development

ℹ ｢wds｣: Project is running at http://localhost:3000/
ℹ ｢wds｣: webpack output is served from /
ℹ ｢wds｣: Content not from webpack is served from /home/andrew/src/rezumei
Running elm make /home/andrew/src/rezumei/src/Main.elm --output /tmp/2020318-15752-12j4e07.9e6hj.js
Success!

    Main ───> /tmp/2020318-15752-12j4e07.9e6hj.js


ℹ ｢wdm｣: Hash: eea91190fcbf33a133ff
Version: webpack 4.42.1
Time: 735ms
Built at: 04/18/2020 4:08:32 PM
     Asset       Size  Chunks             Chunk Names
    app.js    460 KiB     app  [emitted]  app
index.html  266 bytes          [emitted]
Entrypoint app = app.js
[1] multi (webpack)-dev-server/client?http://localhost:3000 ./src/index.js 40 bytes {app} [built]
...
```

What has happened? The Elm upgrade to 0.19 requires us to initialize the elm app differently than before. The repo from the article contains the upgrade to 0.19 commits.

This explains why I was seeing a difference between the Elm 0.19 reference documentation and projects and the article's code.

The article's update contains this bootstrap code in `src/index.js`
```
'use strict';

// require index.html for webpack copy to dist/
require('./index.html');

const {Elm} = require('./Main.elm');

Elm.Main.init({
    node: document.getElementById('main'),
});
```

> Note that the Elm reference projects use a slightly different syntax where their Elm.Main.init() call does not refer to a node in the DOM.

After correcting the elm syntax and running `npm run start`,  the simple Elm UI displays our "hello" text. Now, I can continue following the article on creating the PWA.

Having read and reviewed the manual steps, I am skipping ahead to making the dynamic build. This requires installing some more node modules. Again, I am under the assumption these can be installed as "devDependencies" until such time as this doesn't work for me.

```
$ npm i -D sw-precache-webpack-plugin
$ npm i -D webpack-pwa-manifest
$ npm i -D clean-webpack-plugin
```

To avoid kruft in the output directory, e.g. "dist", I have added clean-webpack-plugin to the mix.


## Test PWA caching

The simple file builds successfully with webpack in both production and development modes. Serving with the webpack-dev-server **will not** workto test the caching behavior of the service worker for the PWA because the manifest.json file is served by index.html. And, as we saw earlier, webpack-dev-server directly serves the index.js file **not** index.html. Installing `serve`, as the article suggests, is quit and painless.

Installing the `server` node package globally makes sense as it has nothing to do with the project itself and is simply a small http server.
```
$ npm install -g serve
$ npm run build
$ server -l 3000 dist/
```

Open http://localhost:3000 again, this time served from `serve` rather than `webpack-dev-server` and you should see the "hello" text from you app. Then, use Chrome DevTools to navigate to Application > Server Workers and check the Offline checkbox. All as described in the article =)

Refresh.

Reload.

It Works!

## AWS Amplify Frontend

Next, let's hook this up to AWS Amplify to publish the initial version.

Login to the Amplify Console. Connect to the git repo. Amplify found the necessary build steps from my webpack setup. The only thing I had to customize here was using my AWS Amplify Elm-enabled Docker image in build Advance Settings > Build image settings, set the name of the build image to `aahamlin97/awsamplify-elm`. This image is available on DockerHub at [https://hub.docker.com/repository/docker/aahamlin97/awsamplify-elm](https://hub.docker.com/repository/docker/aahamlin97/awsamplify-elm).

Once the build image is provisioned, the build steps all succeed and the app is available as shown in the Amplify Console. Retesting the Service Worker support shows that everything works as expected in the live environment, too!

There are a couple notes for the future:
- the build steps report a problem with node-gyp though there does not seem to be any negative side effect to the error
- DevTools console give some Elm optimization suggestions, will need to update the webpack production mode build options at some point

> The node-gyp error was:
> gyp ERR! stack SystemError [ERR_SYSTEM_ERROR]: A system error occurred: uv_os_get_passwd returned ENOENT (no such file or directory)

Now we have published a simple progressive web app written in Elm using AWS Amplify Console!

## AWS Amplify Backend

Of course, the app does nothing...

So let's provision a GraphQL API endpoint backed by DynamoDB using the Amplify CLI.

In Amplify Console of your app, click on the Backend environments tab. This will walk you through the basics. First install Amplify CLI, globally. Then, with the CLI tool installed, initialize your project as shown in the Console.

```
$ sudo npm -g @aws-amplify/cli

----------------------------------------
Successfully installed the Amplify CLI
----------------------------------------

JavaScript Getting Started - https://aws-amplify.github.io/docs/js/start

Android Getting Started - https://aws-amplify.github.io/docs/android/start

iOS Getting Started - https://aws-amplify.github.io/docs/ios/start
```

The first thing to do once amplify CLI is installed is to setup your IAM user for your environment. `amplify configure`.

The Amplify Console skips over this configuration step. Though their tutorial did walk me through it... but that was a few weeks ago and these aren't the types of steps you are likely to remember. Take some time to read through the [https://aws-amplify.github.io/docs/cli-toolchain/quickstart](https://aws-amplify.github.io/docs/cli-toolchain/quickstart). it covers the configuration as well as management of dev, test, prod environments and so forth.

Using `amplify configure` I setup an AWS Profile named for the dev environment I am planning to setup. I will use that profile storing the access id and secret key of my new IAM user in the next step, `amplify init`.

```
$ amplify init  --appId {your_app_id}
```

Match the name of the environment to your git branch, e.g. "master".

Most of this is straight forward, I did run into some problems with the AWS region and the AWS Profile the first time around. Once I reran the configuration steps and setup a new IAM user, the init command worked as expected.

Generating both master and dev environments involved the following:
```
$ amplify add api
```
Again, be sure to match the environment name to your git branch, e.g. "master".

I ran into a problem with the GraphQL generated schema not validating. `amplify api gql-compile` complains that the GraphQL type `ID!` is not valid. I found no report of this issue online but for now I simply used type `String!` as my IDs.

Now that there are 2 environments, switching between them involves two steps:
```
$ git checkout <env>
$ amplify env checkout <env>
```

Make sure you're on the right amplify env before pushing changes!

Once you have created the graphql schema (in the right env) and created it with `amplify push`, go to AWS CloudFormation and AWS AppSync to review the deployments. AWS AppSync also provides an online query editor to test the API.

### GraphQL, & DynamoDB

My initial graphql schema included two `@model` objects with some `@connection` annotations between. To my surprise, amplify generated two DynamoDB tables! Every AWS and Third-party tutorial and presentation I have read states that the a single table is the most preferable from scalability and cost perspectives. I didn't know what to expect in my first attempt but I really want to see if Amplify can create a single table solution.

I removed the initial test code.

```
$ amplify api remove
$ amplify status
$ amplify push
```

Then, ran through and regenerated a new GraphQL schema from scratch following the detailed example found from Trek10.com at [https://www.trek10.com/blog/dynamodb-single-table-relational-modeling](https://www.trek10.com/blog/dynamodb-single-table-relational-modeling). The author nicely walked through converting the Northwind database into a single table DynamoDB model. He followed the advice found in AWS documentation and from a LinkedIn Learning video course on DynamoDB. The ideas finally clicked for me given the sample code linked to in the post that I could deploy into AWS and view in the AWS Console.

Some posts on Reddit state that AWS Amplify does not support building single table solutions. That is _not_ true. The `@model` annotation creates a Table. Therefore a single table solution means your schema.graphql file will only contain a single `@model` annotation but many `@key` annotations to setup the necessary secondary indexes. The Northwind conversion follows similar advice to the LinkedIn Learning course utilizing generic names for the partition key, and composite sort keys.

First things first. List all your known access patterns.

I won't list all of my access patterns here but will show two examples including the mapping of the partition key and composite sort keys. For some context, I am building a job seeker management tool.

1. Get all job descriptions applied in last month.
2. Get all experiences for a work history.

The following table shows how I mapped things out, with some comments.

| Comment | pk | sk (GSI PK) | data (GSI SK) |
|---------|----|-------------|--------------|
| Job description | jobDescId | "JOBDESC" | appliedOn |
| Resume for JD | resumeId | "RESUME" | jobDescId |
| Work History heading | workHistoryId | "WORKHISTORY" | startDate#endDate |
| Experience for work history or highlighted skills | skillId | resumeId -or- workHistoryId | text |

Now, I can navigate to any item by its partition key ID. But, more importantly, without creating additional tables with `@connection` annotations between them, I can find relevant entries, such as my two examples.

1. Getting all job descriptions applied to in the last month, is an index search for `sk = "JOBDESC" AND "data" >= "2020-04-01"`
2. Getting all experiences for a work history, is an index search for `sk = workHistoryId`

The schema sample for this setup is:
```
type Resume @model
     @key(fields: ["pk", "sk"])
     @key(name: "bySortKey", fields: ["sk", "data"], queryField: "itemsBySortData") {
  """
  Partition Key
  resumeID, workHistoryID, skillID, jobDescID
  """
  pk: ID!

  """
  Sort Key
  JOBDESC, RESUME, WORKHISTORY, resumeID, workHistoryID
  """
  sk: String!

  """
  Data
  JobDesc: appliedOn
  Resume: jobDescID
  WorkHistory: startDate#endDate
  Skill: text
  """
  data: String!

  createdAt: AWSDateTime!

  ...
```

### The drawbacks

One drawback to using Amplify to create a single table solution for DynamoDB is that the generated queries and mutations won't be as useful. They will include ALL the fields from your `@model` rather than fine-tuned collections of attributes.

Another drawback is there is no type-checking for the data stored in composite sort keys, "sk" and "data".

## Elm, GraphQL, AWS Cognito

At this point, I have purposefully _not_ added permissions or ownerships to the DynamoDB data, but I did setup authentication on the AWS side using Cognito User Pools. Therefore, while I can execute queries and mutations via the AWS AppSync Console successfully, the first thing I need to add to my elm project is user authentication against Cognito. Then, I can implement the first query.
